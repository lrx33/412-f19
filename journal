Daily EOD reports (End of Day)
------------------------------
year is 2019.
---------------
Nov 13
Can hook up with the ieee80211 layer to signal that we want to operate in 11na or 11ng (radiocaps func in if_run was hacked to achieve this)

November 27
Set up system tap on Ubuntu
iwconfig / iwlist utils use the outdated wext packages, spent some time trying
to get card caps out of these, but did not work. Finally realized linux has something called nl80211/cfg80211 for this communication now. Uses the name (not confusing at all) "iw" for the tool using nl80211 which supersedes iwconfig/iwist.
iw list - does indeed detect that the cards on machine have HT capabilities.
Exploring how exactly iw queries the card for its caps.
Enter systemtap: This is like dtrace probes from fbsd,but on linux. ubuntu also has something called ddebs which are basically dbgsyms (like /usr/include/debug/ on freebsd) to help. Using systemtap, need a full call trace when doing iw set-bitrate.
It is not immediately clear if setting the bitrate is enough to drive using full 11n mode.

Nov 28
Reading the rtx2800.h and rt2x00lib.h
Playing around with iw and iwconfig and enabling debug in the run driver.
IT is not fully clear how exactly the 80211 frame is created, although run's tx and tx_desc are close contestants.
Even after setting mode to 11ng using ifconfig, as soon as association happens with an AP, the mode switches back to
no N. Investigating.

Nov 29
Wireless packet capture! Maybe should have done this earlier.
Seems like the protocol works : probe req / resp -> auth -> assoc req resp.
The 11n thingy is already advertised in the probe request phase and the response depends on it.
The 11n thingy doesn't seem to affect auth step, but does afffect assoc.
Captured the entire transaction on rt2x00 and for run. iwm (onboard intel freebsd) doesn't support monitor mode.
Borrowed a friend's linux machine and ran capture frames. As we are only interested in N for now (ng to be precise)
I disabled the home wifi's 5 ghz completely to force 11g modes (autoselect keeps flipping otherwise).

It is evident that freebsd can;t do N, the probe request doesn't advertise a ton of HT stuff, while linux does.
Next step is to figure out where exactly we can add this code to the run driver and how much of this is handled
in hardware vs host framing logic.

Nov 30
https://www.linux.com/tutorials/linux-wireless-networking-short-walk/
This is a very* good overview of what's happening. We can now look at how the linux mac80211 stack frames probe requests and replicate
the effect into bsd's net80211.
https://www.oreilly.com/library/view/80211-wireless-networks/0596100523/ch04.html goes into details on how mgmt frames are structured (has pictures as well!). And this document https://mrncciew.com/2014/10/08/802-11-mgmt-beacon-frame/ also describes the HT tags in the mgmt frame. https://www.freebsd.org/cgi/man.cgi?query=ieee80211_vap&sektion=9&apropos=0&manpath=FreeBSD+10.0-RELEASE (man page for vap) clears up a lot of basic ideas (think ifconfig wlanX create wlandev run0 command).

Dec 10-11
---------
It is possible that a sniffer running on freebsd WILL NOT pick up on 802.11n data frames over the air in monitor mode...even worse, it will MISINTERPRET those packets and flag then as 802.11b/g packets. After a certain period of no progress, it seems like running a capture on a (more developed....*gulp* distribution) Ubuntu machine with intel driver (freebsd said iwm doesn't support master mode / monitor mode) was able to capture these packets. It also seems that association request / response frames are the *master* frames which are used for deciding which rate will be picked. the tx policy rates picked are independent (as long as they were in assoc message from other side, as suported rates), you should be good. After assoc, asus device on linux at least, starts sending out 11n packets from the get go. We will do the same on freebsd now. There's no explicit "There will be 11n traffic now" messages.

Dec 12
------
/usr/src/sys/net80211/ieee80211_var.h
ieee80211com is the primary struct to understand in order to do something with the wifi stack. 
We're interested in the ic_transmit method specifically, as htcaps should have been already parsed from the assoc response. This now means that run_transmit needs to have 11n bits to properly make packets which are 11n capable (make sure that the htcaps were indeed set properly);

run_transmit -> run_start -> run_tx -> get stuff from mbuf (see the mbuf(9) man page)
(transmit routines, start routines, should only have one according to Kong, but I guess this is fine?)

The run_tx method casts the mbufs to an ieee80211_frame (defined in ieee80211.h) but the struct doesn't make much sense without some background. https://witestlab.poly.edu/blog/802-11-wireless-lan-2/ diagram at top of page clears some stuff up.

Dec 13
------
Found the bits in the linux driver which set the desired state before putting frames on the wire. They mostly live in rt2x00reg.h (see rate_modulation enum). This is what gets set in the tx descriptor before
a frame is transmitted, so we need to replicate this in the freebsd stack. The freebsd stack does have its own tx descriptor code base which seems quite like the linux implementation. One major source of problems is assoc'ing with an access point on freebsd using wpa_supplicant and wpa_supplicant spewing out thousands of errors like "invalid routing message 14" and not associating. Maybe the changes to the run driver and driving it bananas, but it seems unlikely at this point. Not sure if should fix wpa_supplicant first, or just let it be and find a way around it.

Submitting report. But this journal shall continue.

May 09, 2020
------------
run_tx_set_desc() is called by run_tx, run_tx_mgt, run_tx_param, run_proto

For linux setup:
DONT STOP NETWORK MANAGER SERVICE
CONNECT TO SSID ON REQUIRED FREQ BAND
iw dev wlan0 add interface mon0 type monitor
set mon0 up
set frequency 2412 wlan0

For BSD:
ifconfig wlan1 create wlandev run0

.   if_run.c             169691 C/*l             /usr/src/sys/dev/usb/wlan/if_run.c
 %  *Man mtod*            30428 Man              
    ieee80211_var.h       44633 C/*l             /usr/src/sys/net80211/ieee80211_var.h
 %* *grep*                 3006 Grep:exit [ma... 
    ieee80211_wds.c       23826 C/*l             /usr/src/sys/net80211/ieee80211_wds.c
    ieee80211_sta.c       60339 C/*l             /usr/src/sys/net80211/ieee80211_sta.c
    ieee80211_freebsd.c   27430 C/*l             /usr/src/sys/net80211/ieee80211_freebsd.c
    ieee80211_proto.h     18659 C/*l             /usr/src/sys/net80211/ieee80211_proto.h
  * ieee80211_node.c      87647 C/*l             /usr/src/sys/net80211/ieee80211_node.c
    ieee80211_ddb.c       29868 C/*l             /usr/src/sys/net80211/ieee80211_ddb.c
    ieee80211_adhoc.c     30622 C/*l             /usr/src/sys/net80211/ieee80211_adhoc.c
    _ieee80211.h          25848 C/*l             /usr/src/sys/net80211/_ieee80211.h
    ieee80211_ht.c        98937 C/*l             /usr/src/sys/net80211/ieee80211_ht.c
    ieee80211_node.h      21631 C/*l             /usr/src/sys/net80211/ieee80211_node.h
    ieee80211.c           69775 C/*l             /usr/src/sys/net80211/ieee80211.c
    if_runvar.h            6957 C/*l             /usr/src/sys/dev/usb/wlan/if_runvar.h
 %  *Man ieee80211*       25822 Man              
    if_runreg.h           48418 C/*l             /usr/src/sys/dev/usb/wlan/if_runreg.h
    bwimac.c              46951 C/*l             /usr/src/sys/dev/bwi/bwimac.c
 %  net80211               5222 Dired by name    /usr/src/sys/net80211/
    if_ural.c             56595 C/*l             /usr/src/sys/dev/usb/wlan/if_ural.c
    rt2x00queue.c         33801 C/*l             $HOMElinux/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
    rt2x00dev.c           41586 C/*l             $HOMElinux/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
    rt2x00reg.h            5659 C/*l             $HOMElinux/drivers/net/wireless/ralink/rt2x00/rt2x00reg.h
 %  rt2x00                 2875 Dired by name    $HOMElinux/drivers/net/wireless/ralink/rt2x00/

Important files ^^^

May 18, 2020
https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=246557 Reported a bug that was found when trying to run wireshark
remotely on Peter's laptop (running Ubuntu 18.04) and having a kernel panic on bsd as running wireshark (ssh over X
forwarding).
This was a duplicate bug, updating to tip of stable/12 svn fixed the issue (although wireshark doesnt run over X, resorting to run it on the other laptop itself).

May 19, 2020
Configured to capture on a channel 9 as that was less noisy and then wireshark could actually capture data packets (probably limited in channel 1 due to too much noise from highly active other APs).
Anyhow, the differences between what we advertise in capabilities vs what linux does:

(On comparing association request between both in pcapng), the following difference;
In fixed parameters:
Linux has capability information set to 0x1431
We have 0x0431, we are missing Radio Measurement: Implemented bit.
Our listen interval is 0x0001 while linux is 0x0005

In Tagged parameters
Linux has 112 bytes, we have 91 bytes

* SSID parameter: identical
* Supported rates tag: We have the 8 rates that linux has (1, 2, 5,5, 6, 11, 9, 12 , 18) but we have them marked (B) (not sure what B is 802.11b perhaps?). Anyway the bits are different and these are different on the wire therefore.
* Same story as supported rates for EXTENDED SUPPORTED RATES TAG.
* We are completely missing the power capability tag (that probably is the difference in size of tagged params)
* RSN Information is identical
* HT capabilities > HT Cpabailities Info. Linux has 0x03fe vs our 0x03bd.
  - Linux has HT LDPC coding capability OFF.
  - Linux has HT support channel width ON.
  - Linux has HT Short GI for 40 MHz ON.
* HT capabilities > A-MPDU Parameters: Linux has 0x13 vs our 0x18.
  - Maximum Rx A-MPDU length is 0x3 on linux (65k bytes) vs our 00 (8192 bytes)
  - MPDU Density is 0x4 on Linux for 2 microsec vs our 0x6 for 8 microsec.
* HT capabilities > MCS Set RX SUPPORTED MODULATION AND CODING SCHEME (One bit per modullation): Linux has 3 spatial streams vs our 2.
  - Linux has Rx bitmask Bits 16-23 set to 0xff while we have 0x00
  - Linux has Bit 32 set to 1 we have set to 0.
  ---- Not a part of the bitset.
  - Linux has Tx supported MCS Set Defined (set to 1), we have 0.
* Extended parameters: we are missing this tag completely.
* RM Enabled capabilities: We are missing this entirely.

May 21, 2020
Channels are used (get_suprates()) and then it is mapped to a rateset (chan2mode is used to calculate PHY). For 'g', it seemed like there was a 'B' mask on that, which has now been removed (in ieee80211.c).

The advertised rates have been fixed with changes to ieee80211.c. As it was problematic to keep recompiling the kernel every time, the wlan (ieee80211) has been commented in GENERIC which leads to having all of them as loadable modules! Now that the rates and the HT capabilities has been taken care of, it is time to move to the A-MPDU stuff and enable that in the driver.

May 22, 2020
ADRIAN is gonna add IBSS 802.11n support soon.

22:37 < lrx33> adrian: thanks, I'll wait for your patch
22:37 < adrian> np
22:37 < adrian> bbl
22:37 < lrx33> I'm gonna park all dev effort on run for now I guess
22:37 < lrx33> I don't know where to go from here
22:37 < adrian> oh
22:37 < adrian> no, so
22:38 < adrian> let's get the 11n driver bitsin
22:38 < adrian> under that ifdef
22:38 < adrian> do you have a commit bit?
22:38 < lrx33> no commit bits
22:38 < adrian> ok
22:38 < adrian> lmk what youwanna do about the non-net80211 bits
22:38 < adrian> I don'tmind landing it tonight as a checkpoint
22:39 < lrx33> they are all in the #ifdef IF_RUN_11N #endif tags so they could go into the driver from what I know
22:39 < adrian> then I suggest getting 802.11n tx/rx going without ampdu formation (youcan idsable negotiating it)
22:39 < adrian> so you can get the rate stuff working without ampdu
22:39 < adrian> that and 40mhz channels is a big deal to get right
22:39 < adrian> bbl
22:39 < lrx33> adrian: thanks! have fun 

Basic document about modulation in wifi & rate negotiation:
https://documentation.meraki.com/MR/WiFi_Basics_and_Best_Practices/Wireless_Fundamentals%3A_Modulation
https://documentation.meraki.com/MR/WiFi_Basics_and_Best_Practices/802.11_fundamentals%3A_Modulation

May 23, 2020
Found a datasheet! Although its not for this exact chipset, it will do (its for a 5350 chipset).
Learned more about channel promotion using ht flags and how the net80211 code maintains both channels in the 2,4GHz band (HT and NON HT)
For now only HT20 is being investigated.
The rt2x00 driver does some stuff in the tx_Descriptor and freebsd has most of the registers already in place.
The tx descriptor format is kinda useful from the datasheet in this dir (see pg 207 of that).
Need to figure out what bits need to migrate from rt2x00 to run driver now in the tx descriptor generation.
https://cdn.sparkfun.com/datasheets/Wireless/WiFi/RT5350.pdf for the datasheet.

May 24, 2020
https://www.digitalairwireless.com/articles/blog/demystifying-modulation-and-coding-scheme-mcs-index-values

This article is a  must read for understanding what MCS is. Can't get very far without understanding MCS now.

05:59 < lrx33> weeeeeeeee, I have the first 802.11n frames on the wire with the newest changes to run(4)!
06:45 < lrx33> What does it mean to operate with IEEE80211_FIXED_RATE_NONE? Does that mean that the rate once decided will never change again?
07:18 < lrx33> hmm, seems like the amrr_ridx calculation logic always yields an index of 0 and that's why we can't respond to the sender in time (longer ack durations for lower indices)
07:19 < lrx33> If I manually set the ridx to 2 whenever it was supposed to be 0, I can achieve ~2.5 MB/s transfer rates (contrast this with 1 MB/s a few hours ago :D)
15:50 < adrian> hihi
15:50 < adrian> oh cool!
15:50 < adrian> that's pretty fucking great lrx33 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
15:52 < adrian> lrx33: oh so that means that the rate isn't fixed
15:52 < adrian> lrx33: that's eg if you type "ifconfig wlan0 ucastrate 1"
15:52 < adrian> lrx33: in 11n tha'ts MCS1, in 11b it's 1MBit
15:53 < adrian> lrx33: if you do "ucastrate any", it becomes FIXED_RATE_NONE so rate control (in this instance) will kick in
15:53 < adrian> you should go look at why amrr_ridx keeps choosing ridx 0 (which I guess is MCS0? Go look at the data path)
15:53 < adrian> it may need some ACK responses from the driver to choose a higher MCS rate

***
The amrr_rate idx doesn't change from 0 for some reason, and need to investigate why that is.

May 25, 2020
0:28 < lrx33> adrian: about the run driver and amrr ridx calculation, i think it is only non prot frames that we have the numbers for
20:29 < lrx33> run0: amrr retrycnt=61 success=784 failcnt=0
20:29 < lrx33> run0: amrr retrycnt=113 success=937 failcnt=0
20:30 < lrx33> So these are long retransmits. I couldn't find a register in the datasheet that tracks rts/cts separately, so I added some debug to the run_sendprot() method which doesn't report any frames
20:30 < lrx33> So i concluded all of the reported counts in the statistics must be non prot frames
20:57 < lrx33> Could i verify this using monitor mode on another device somehow?
21:04 < adrian> ok
21:05 < adrian> yeah, you need another laptop in monitor mode
21:05 < adrian> rts/cts is useful for ht
21:05 < adrian> esp if you hvae pre-11n stuff around
21:05 < adrian> or it's busy air
21:05 < adrian> retrying without failures isn't a BAD thing per se
21:05 < lrx33> with failures?
21:06 < adrian> if fail=0 then that's fine
21:06 < adrian> some long retries are expected
21:06 < adrian> unless you're like 6-10ft awy from the AP
21:06 < adrian> then I'd expect none? :)
21:07 < lrx33> router is on the ground, adaptor is on a ~3 ft high table about ~4ft horizontal distance (total distance ~5ft)
21:07 < adrian> ok
21:07 < adrian> so it can't be TOO close or it overwhelms the receiver
21:07 < lrx33> I also picked channel 11 as that had the least traffic according to some analysis i did
21:07 < adrian> but 5ft is a good distance
21:08 < adrian> is that MCS0 ?
21:08 < lrx33> well, amrr ridx keeps getting set to 0
21:08 < adrian> yeah
21:08 < adrian> but in the driver
21:08 < adrian> is that MCS0 ? ;p
21:08 < lrx33> i have no idea :p
21:08 < adrian> ridx is an index into a phy table with rates
21:09 < adrian> and the driver has to turn that into whatever the per-packet or whatever representation of a PHY rate is in hardware
21:09 < adrian> when transmitting
21:09 < adrian> have you updated your diff? I'd like to take another quick look
21:09 < lrx33> adrian: yeah, https://reviews.freebsd.org/D22840 should have all the useful stuff
21:10 < lrx33> I don't fully understand the MCS part. the existing driver code only has 11g PHY rates in the rate table
21:10 < lrx33> and when generating the tx descriptor, I only OR with the correct PHY according to the channel we're operating on
21:11 < lrx33> mcs = rt2860_rates[ridx].mcs; 
21:11 < adrian> let's see
21:11 < lrx33> This gets set, and ridx is 0, so yeah it would pick the 0th index from the rate table if ridx was 0
21:12 < adrian> is it a 3x3 stream device?
21:12 < lrx33> according to wireshark captures, yes
21:12 < adrian> ok
21:12 < adrian> interesting
21:12 < adrian> how many antennas does it have?
21:12 < lrx33> umm, I think 3 but its not exactly visible: its a fancy pyramid
21:12 < adrian> ok
21:13 < lrx33> https://www.asus.com/Networking/USBN66/
21:13 < adrian> yeah
21:13 < lrx33> for the specs: https://www.asus.com/Networking/USBN66/specifications/ (says 3 antennae)
21:13 < adrian> where's that mcs = line in your driveR?
21:13 < lrx33> if_run.c : line 3326
21:14 < adrian> push an update? :)
21:14 < adrian> it's not here
21:14 < lrx33> beginning of run_set_tx_desc() function
21:14 < adrian> only |= PHY_HT_MIX
21:14 < lrx33> its not in the diff, its always been there
21:14 < adrian> oh ok
21:14 < lrx33> it was in the original run driver
21:14 < adrian> wait a sec
21:15 < adrian> ok
21:15 < adrian> there's no mcs rates
21:15 < adrian> in rt2860_rates
21:15 < adrian> in rt2860_rates[]
21:16 < lrx33> yeah, there arent ;)
21:16 < adrian> it has CCK and OFDM rates
21:16 < adrian> but no MCS rates
21:16 < adrian> i highly suggest setting number of streams to 1
21:16 < adrian> just for now
21:16 < lrx33> ok
21:16 < adrian> and then you'll need to add MCS 0.. 7
21:16 < adrian> and you'll need to go see what it's doing with ridx
21:16 < adrian> cause
21:17 < adrian> thisw
21:17 < adrian>         /* setup TX Wireless Information */
21:17 < adrian>         txwi = (struct rt2860_txwi *)(txd + 1);
21:17 < adrian>         txwi->len = htole16(m->m_pkthdr.len - pad);
21:17 < adrian>         if (rt2860_rates[ridx].phy == IEEE80211_T_DS) {
21:17 < adrian>                 mcs |= RT2860_PHY_CCK;
21:17 < adrian>                 if (ridx != RT2860_RIDX_CCK1 &&
21:17 < adrian>                     (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
21:17 < adrian>                         mcs |= RT2860_PHY_SHPRE;
21:17 < adrian>         } else
21:17 < adrian>                 mcs |= RT2860_PHY_OFDM;
21:17 < adrian>         txwi->phy = htole16(mcs);
21:17 < adrian> this bit? See it's checking the phy type for the ridx
21:17 < adrian> and setting some flags appropriately?
21:17 < adrian> you need to do the following
21:17 < adrian> add mcs 0.. 7
21:17 < adrian> with IEEE80211_T_HT as the phy
21:18 < adrian> then in this funciton, hopefully you'll get a ridx that's an MCS rate, and I'd print it per packet there
21:18 < adrian> you shouldn't set the HT_MIX or whatever flags based on the channel mode
21:18 < adrian> only o nthe ridx
21:18 < adrian> cause the ridx dictates both the hardware value that you're programming into the phy/mcs descriptor
21:18 < adrian> AND
21:18 < adrian> what the PHY configuration is
21:19 < adrian> eg, you CAN send CCK/OFDM rates on 2GHz channels cause you can still do 11b (cck) and 11g (ofdm) rates
21:19 < adrian> i wonder if I have an if_run USB nic in my pile to go test with
21:19 < lrx33> thx, I'll make these changes
21:20 < lrx33> I don't understand how this would affect the ridx calculation in the amrr code though>
21:20 < lrx33> If that still returns an ridx of 0, we would pick the CCK rate again instead of the HT MCS0 rate...or not?
21:21 < adrian> cause chances are it tried higher and got told to go away
21:21 < adrian> I'd have to go see if it's really negotiating HT rates or not
21:21 < lrx33> i'll check that
21:21 < lrx33> I already added debug to the amrr code
21:21 < adrian> i /think/ net80211/amrr is ONLY choosing HT ratetable entries
21:21 < adrian> I' have to fire up if_iwn again to check
21:22 < adrian> then it's up to the driver to turn it into its own rate index
21:22 < adrian> cause the driver rate table != the net80211 phy rate table
21:22 < adrian> yeah, the net80211 "rate" representation is dumb
21:22 < adrian> non-11n, it passes in 2* the rate ("dot11rate")
21:22 < adrian> eg 1MB is 2, 5.5MB is 11, 54Mb is 108
21:22 < lrx33> yeah i saw some comments saying that it uses half mb/s units
21:23 < adrian> and then MCS it's either (and I forget rn) 0x80 + MCS, or 0 + MCS, I forget
21:23 < lrx33> probably where it declares all the 11b/11g ratesets in net80211
21:23 < adrian> I think it's 0x80 + MCS
21:23 < lrx33> 0x80 | MCS
21:23 < lrx33> iirc from comments again
21:24 < lrx33> ah, okay, its all coming together now i think...how the rate is communicated from the net80211 code, and then the driver checks if the MCS mask was set
21:24 < lrx33> in the rate,and then picks accordingly from its private rate table (rt2860_rates in our case)
21:24 < adrian> so right, and data->ridx starts as amrr_ridx
21:24 < adrian> yeah
21:24 < adrian> and hax like
21:24 < adrian>                 ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
21:24 < adrian>                     RT2860_RIDX_OFDM6 : RT2860_RIDX_CCK1;
21:24 < adrian> that's it overriding EAPOL frames with the lowest rate for 11a or 11b
21:25 < adrian> but this
21:25 < adrian>         ieee80211_ratectl_tx_update(vap, txs);
21:25 < adrian>         rn->amrr_ridx = ieee80211_ratectl_rate(ni, NULL, 0);
21:25 < adrian> in run_iter_func()
21:25 < adrian> I dnuno what amrr_ridx is trying to be here, I forget what ratectl_rate() returns
21:25 < adrian> I think it's working by magic, not by intent
21:26 < adrian> yeha, amrr_rate()
21:26 < lrx33> I checked that, it's here: https://github.com/freebsd/freebsd/blob/master/sys/net80211/ieee80211_amrr.c#L334
21:26 < adrian> ni->ni_rates or ni->ni_htrates
21:26 < adrian> it's an index into that
21:26 < lrx33> aha
21:26 < adrian>                         ni->ni_txrate = rs->rs_rates[rix];
21:26 < adrian> then there's thta
21:26 < adrian> that translates the amrr rate into the dot11rate
21:26 < adrian> yeah
21:26 < adrian> that's what's going on
21:26 < lrx33> so if it picked htrates table in amrr, then we should go mcs route
21:26 < adrian> well
21:27 < adrian> first up is
21:27 < lrx33> otherwise just non mcs
21:27 < adrian> the run driver needs to not just trust that the static rate table it has
21:27 < adrian> maps 1:1 to whatever is in net80211
21:27 < adrian> so like what we do in ath and in if_iwn, we gotta write a functoin that maps the net80211 tx rate index
21:27 < adrian> into an offset inside of the right net08211 rate table
21:28 < adrian> look in iwn_tx_rate_to_linkq_offset(struct iwn_softc *sc, struct ieee80211_node *ni,
21:28 < adrian>     uint8_t rate)
21:28 < adrian> in if_iwn.c
21:28 < adrian> the "use the correct rate table" needs to be a net80211 method, cause it's dumb otherwise
21:28 < adrian> but yeah, you can use that to get the dot11rate and then iterate through the hardware rate table to set amrr_rix and rix
21:28 < adrian> because /that/ will be the rate index /inside of the hardware table/
21:28 < adrian> and then the rest of this makes sense
21:29 < adrian> (to me, hopefully to you too!)
21:29 < adrian> back in a bit
21:31 < lrx33> fuck, it makes the most sense so far ever since I started hacking the run driver
21:31 < lrx33> I'll go steal the mcs rate values from mcsindex.com
21:34 < lrx33> adrian: would you mind if I copy this IRC chat verbatim into a sorta journal I've been maintaining (and potentially 
               share it with others outside this IRC channel)?
21:48 < lrx33> actually, I think I'll steal values from 
               https://github.com/torvalds/linux/blob/master/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c#L879 instead of 
               mcsindex.com
21:58 < lrx33> Umm, about the mcs indices, it seems that different PHYs could have the same mcs indices: like CCK has its own mcs 
               index 0, and OFDM has its own mcs index 0, how do I get the correct values for the T_HT PHY for mcs 0..7?
22:01 < idwer> lwhsu: that file has a GPL license, FYI
22:01 < idwer> eh lrx33
22:01 < lrx33> idwer: I wouldn't copy that file yeah
22:02 < lrx33> DOn't want to taint the kernel now, do we :)
22:26 < adrian> back
22:26 < adrian> yeah you can do it
22:27 < adrian> honestly that's just a good reminder that we need to abstract out the rate lookup into net80211
22:27 < adrian> rather than drivers doing that same ns_rates logic
22:27 < adrian> esp if we start doing 11ac per-packet transmit rate lookup for oddball chips that let us
22:28 < lrx33> adrian: yeah, I think the driver should only scan its own rate table while net80211 emits enough information along 
               with the rate index
22:28 < lrx33> btw, it seems the run driver isnt using amrr, its not using rssadapt, its using NONE for ratectl
22:29 < adrian> oh, even better, ok
22:30 < adrian> why's it not running amrR?
22:30 < adrian> do you not have it loaded?
22:31 < lrx33> Right, didnt have it loaded, its using amrr now.
22:31 < lrx33> damn, all this while it was using ratectl_none and returning ridx 0
22:31 < lrx33> now its actually using amrr and returning ridx 7!
22:31 < adrian> ha ok
22:31 < adrian> so next up
22:31 < adrian> the mcs tables
22:31 < adrian> and rate table
22:32 < lrx33> (and fwiw, amrr is indeed checking the htrates table according to debug)
22:32 < lrx33> yeah, how do I get the correct values for the rt2860_rates table?
22:32 < adrian> I dunno, look in hte linux driver?
22:32 < adrian> see what it's doing for MCS0..31 ?
22:32 < lrx33> https://github.com/torvalds/linux/blob/master/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c#L879 is where the 
               driver sets its supported rates
22:33 < lrx33> but it seems that this is the equivalent of our rt2860_rates table
22:33 < adrian> that's just cck/ofdm
22:33 < lrx33> ok, ill go hunting
22:40 < waddlespl> markj: https://i.imgur.com/eHlimlP.png
22:40 < waddlespl> (object_cache is how our mbuf system is implemented)
22:43 < waddlespl> this is from the same person that reported the NULL dereference KDL
22:50 < lrx33> ok, found how the linux driver does it
22:50 < lrx33> it seems like it just copies the mcs index value into the hardware register!
22:50 < lrx33> https://github.com/torvalds/linux/blob/master/drivers/net/wireless/ralink/rt2x00/rt2800lib.c#L773
22:51 < adrian> yeah
22:51 < adrian> so you can do that
22:51 < adrian> you just need to make sure you do it based on which mode/table
22:51 < adrian> brb
22:52 < lrx33> I'll set the mode to be HT_MIX and copy in just the mcs value now
22:52 < adrian> does linux set HT_MIX ?
22:52 < adrian> also what's it set for ctrl_rix
22:54 < lrx33> It sets it to greenfield or mix at runtime depending on flags, 
               https://github.com/torvalds/linux/blob/master/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c#L460 see
22:54 < adrian> ok
22:54 < adrian> set it to mix for now
22:54 < lrx33> Yeah about ctrl_rix, what does ctrl_rix actually mean? mcs index for management traffic?
22:54 < lrx33> or acks?
22:54 < adrian> yeah
22:54 < adrian> it's the speed it sends RTS, CTS and ACK
22:54 < lrx33> o.O
22:55 < adrian> normally it's like 6MB OFDM for lower MCS, and 24MB OFDm for higher
22:55 < adrian> it's in that table
22:55 < lrx33> yeah i saw the spl_dur, ack_dur in rt2860_rates
22:55 < adrian> but if you're not using the table, you gotta manually set it
22:55 < adrian> yeah
22:55 < lrx33> wait so spl_dur is rts/cts duration aka transmission speed aka mcs index?
22:55 < adrian> no
22:55 < adrian> ok so
22:55 < adrian> when you send the packet duration
22:55 < adrian> in the PLCP PHY header over the air
22:55 < adrian> it includes any RTS/CTS
22:55 < adrian> and the data path
22:55 < adrian> part
22:55 < adrian> and any ACk part
22:56 < adrian> and any interframe spacing (IFS) parts
22:56 < adrian> so that anyone listening for whom the frame is NOT for htem or they can't decode it? They just update their NAV 
                (network access vector) timer with that duration
22:56 < adrian> so to simplify things, lots of hardware just has software calculate those
22:56 < adrian> in case you need to do crazy shit like add extra time to the announced duration
22:56 < adrian> so ack_dur is the ACK duration
22:56 < adrian> and spl_dur is likely any RTS exchange
22:57 < adrian> oh
22:57 < adrian> sp_ and l_ack_dur is is preamble for 11b rates
22:58 < adrian> there's long and short preamble, it's a CCK thing
22:58 < adrian> they're the same for OFDM rates
22:59 < lrx33> ok, understood parts of this, guess it'll be even clearer once I hack on more stuff
23:00 < adrian> yeah
23:00 < adrian> so
23:00 < adrian> my suggestoin is
23:00 < adrian> for now, you can totally just use 6MB for RTS/CTS and ACK
23:00 < adrian> so
23:00 < adrian> set ctl_ridx to 6
23:00 < adrian> sorry, 4
23:00 < adrian> that's 6MB in that rates table
23:00 < adrian> and 60/60 for sp/lp ack dur
23:01 < adrian> also
23:01 < adrian> ic_protmode != ic_htprotmode
23:02 < adrian> oh
23:02 < adrian> cool
23:02 < adrian> run_updateprot_cb() does the rts/cts config and calculation, it's not done per frame?
23:02 < adrian> anyway, ic_htprotmode is what you are supposed to look ta for 11n protection; take a look at what at least ath is 
                doing when looking at ic_htprotmode
23:03 < adrian> cause by default people don't turn on rts/cts for 11abg, but for 11n you're supposed to do it by default to 
                improve reliability
23:03 < adrian> but at least yeah, let's get the tx phy config right for mcs rates and see what else is going on. :P
23:04 < lrx33> I'll probably leave prot for right after the tx/rx/mcs stuff is sorted and we can get the right setup with higher 
               rates
23:04 < adrian> yeah
23:04 < adrian> so don't worry about reliability irght now
23:04 < adrian> at least get some printing in the tx setup path to see whta the descriptor setup looks like
23:04 < adrian> and we can make sure it isn't busted
23:04 < lrx33> I'm still getting used to the prot stuff. yeah what I gathered reading online articles was it was most important to 
               intermix with legacy or non 11n clients
23:04 < adrian> yeah
23:05 < adrian> good show for sticking with it. :P
23:09 < lrx33> meanwhile, the most important diagram in the world for run driver devel (me at least) is officially here: 
               https://cdn.sparkfun.com/datasheets/Wireless/WiFi/RT5350.pdf pg 209
23:10 < lrx33> I also want to make structs for the word inn the descriptor, and ill write a pretty print function while im at it. 
               Its easier than messing with these bits and getting something messed up
23:10 < lrx33> but maybe thats for later...
23:11 < adrian> haha
23:11 < adrian> you do you. :P
23:13 < adrian> shit this is a nice datasheet :p
23:13 < lrx33> XD seems like someone's experience of dealing with "implement shit rn" vs "it would be nice to clean this up" is 
               showing up xDDD
23:13 < lrx33> adrian: it is!
23:13 < adrian> hahah
23:13 < adrian> working code trumps nothing
23:13 < adrian> THEN clean it up
23:14 < lrx33> yeah, im gonna abandon cleaning up this mess ;p
23:14 < lrx33> for now get it up
23:14 < lrx33> asap
23:14 < adrian> yeah
23:14 < adrian> just take notes
23:14 < adrian> I'm taking a "fix the fucking rate table fetching and stuff" as a net80211 refactor
23:15 < adrian> cause a few drivers have to replicate this nonsense now and it's really stupid
23:15 < lrx33> Ill put this into a separate file
23:16 < lrx33> btw, I might potentially share this irc chat verbatim with other people or put it in a github repo, tell me if you 
               dont want that
23:17 < adrian> yeah
23:17 < adrian> do it
23:17 < adrian> I'm ok with that
23:19 < lrx33> https://github.com/lrx33/412-f19/blob/master/journal_adriann 
23:19 < lrx33> new file with kinda common stuff that needs attention later
23:20 < adrian> cool

**** Next up in development:
03:08 < adrian> tidy things up. :P
03:08 < adrian> heh
03:09 < adrian> and do iperf tests
03:09 < lrx33> i found that the driver
03:09 < lrx33> locks up sometimes
03:09 < adrian> once we know it works, next is ampdu rx
03:09 < lrx33> witho or without my changes
03:09 < adrian> which is mostly getting htcaps right during driverinit and tagging mbufs right as M_AMPDU
03:09 < adrian> in the driver rx path
03:09 < adrian> then, next is ht40
03:09 < adrian> then we test tfoutofi t


May 26, 2020
RX AMPDU development begins.
20:33 < lrx33> adrian: about ampdu, fixx up the rx side first?
20:34 < lrx33> and do all the ifconfig settings like -rxampdu translate to changes to the vap structures which then net80211 uses for generating info elements in the mgt frames?

21:15 < adrian> lrx33: yeah, rx side first
21:16 < adrian> lrx33: so rx ampdu is mostly done in net80211 here, but we need to make sure we setup the maximum ampdu size, and ampdu delimiter density right in the HT capinfo field
21:16 < adrian> lrx33: which you currently have as a number from linux, but we should properly convert the htinfo/htcap into net80211 flags

21:27 < lrx33> adrian: checking the run driver...
21:28 < lrx33> adrian: yeah, run doesn't seem to be doing this
21:29 < lrx33> I checked run_rx_frame()
21:33 < lrx33> I added this code to run, svn diff is running, ill update the phab review
21:34 < lrx33> About run_getradiocaps (or getradiocaps() in a driver in general), does that mean that the driver reports EVERYTHING the hardware is capable of? Or should it consult the vap (respect ifconfig settings, etc) when it sets the 
               capability flags?
21:48 < adrian> everything the radio is capable of
21:48 < adrian> ifconfig settings will be merged into it
21:51 < adrian> what email address should I use for committing stuff lrx33 ?
21:51 < adrian> And what's your name for the commit?
21:51 < adrian> cause a couple of these bits I can just land..
21:55 < lrx33> adrian: Name is Ashish Gupta
21:55 < lrx33> adrian: email address, can you use ashishgu@andrew.cmu.edu for this?
21:56 < lrx33> That's my school, I just graduated, so this would be a nice going away present :p
21:56 < adrian> sure
21:56 < lrx33> PS - The comments in if_runreg.h
21:56 < adrian> i saw
21:56 < lrx33> about the datasheet, I think those could go in too
21:56 < adrian> i'll hopefully have some here soon
21:56 < adrian> well
21:56 < adrian> i'd like to try and get the datasheet put somewhere more permanent
21:56 < adrian> so it won't , you know, disappear. :P
21:57 < lrx33> adrian: sure, we could figure out what to do about that later
21:57 < lrx33> I'm holding it in my repo, and the journal / notes im maintaining
21:57 < adrian> cool
21:58 < adrian> right now i'm mucking around with syslog support in freebsd-wifi-build so I can start actually getting /any/ logs stored and streamed off the AP
21:58 < adrian> but at least my freebsd home APs are no longer COMPLETELY shit
22:00 < lrx33> adrian: is that a freebsd way of doing wifi development?
22:00 < adrian> it's adrian's way of doing wifi development
22:00 < adrian> on old (now) MIPS 11n atheros hardware
22:01 < adrian> but i'll likely extend it to ARM once we get athp in the tree and ipq4019 support
22:01 < adrian> it's basically my image building stuff to build 8/16mb NOR flash images for my test APs
22:01 < adrian> but I keep it online for others to also mess with
22:01 < adrian> what you're doing works for you, so keep doing it. :-P
22:01 < lrx33> ah that's pretty cool
22:01 < adrian> yeah
22:01 < lrx33> haha yeah, run(4) for now
22:01 < adrian> I'm about to go fuck with reroot
22:01 < lrx33> alright, ill try and fix up the ampdu stuff in run
22:01 < adrian> cause I really wanna see if I can do an in system reprogram with it
22:01 < adrian> yeah
22:01 < adrian> it should be pretty easy
22:01 < adrian> like
22:02 < adrian> look at the ampdu density config in linux for run
22:02 < adrian> and make sure it's set right (it's 2 right now)
22:02 < adrian> and see if the linux code does anything (eg a firmware call) to tell the run firmware to expect ampdu rx
22:02 < adrian> some firmware (eg iwn) needs you to set it up explicitly
22:02 < lrx33> I thought ampdu was a *MUST HAVE* for 11n
22:03 < adrian> ath10k will handle AMPDU negotation (called ADDBA/DELBA) in firmware and sends you a notfication
22:03 < adrian> ath doesn't care; it'll just block-ack frames and send them to you, and you gotta do it yourself
22:03 < adrian> well
22:03 < adrian> it's required, but you can totally rrefuse to accept negotiating it
22:03 < adrian> because, get this
22:03 < adrian> back in the early days, the AP chips all ran firmware, bar atheros
22:03 < adrian> and they had limited numbers of AMPDU resources
22:03 < adrian> eg mwl(4)
22:04 < adrian> so once you ran out of AMPDU TX/RX sessions, you couldn't add more, so you had to fail negotiation
22:04 < adrian> so you can totally just reject it during ADDBA negotation, but you'll never pass certification if you ALWAYS do it
22:04 < adrian> so that's what we do for 11n bring-up
22:05 < lrx33> very cool!
22:05 < lrx33> yeah i imagine that makes dev work a lot easier, not worrying about ampdu at the start
22:05 < lrx33> (it sure did in this case)
22:06 < lrx33> I'll go check out rt2x00 now, it makes a lot more sense compared to a week ago, especially cuz I have the datasheet txwi diagrams etc now
22:06 < lrx33> so shouldnt be a long time hopefully, ill bbl with some new stuff 

May 27, 2020
Wireshark! The filters mean different things with wlan.sa wlan.da wlan.ra and wlan.ta . The RA/TA is what we need for looking at CTS/RTS frames and ACKs and block acks. While sa/da is good for data logical endpoints, we need to look at per hop as thats how CTS/RTS and ACK/BAcks work.

iperf server does the download! WTF.

UDP iperf testing
for the client: iperf -c ip -i 1 -t 20 -u -b 30m
for the server: iperf -s -u -i 1

May 28, 2020
Adrian implemented AMSDU in net80211! And made some minor fixes regarding ridx calculation and merged the review from phab (Add HTCAPS) to his tree. Everything seems to work fine, we'll know tomorrow. Time to focus on "05:53 < adrian> lrx33: then yeah, I think focusing on 1/2/3 stream configuration correct, getting 5g channels to work, and then HT40 to work".

Jun 2, 2020
Adrian has been hacking on the 5g thingy with his new USB N66.
Opened a review https://reviews.freebsd.org/D25108 which sets the right number of tx/rx streams same as linux driver.


03:15 < adrian> lrx33: my 5g run showed up
03:15 < adrian> lrx33: and I found a bug in 6m ofdm support already
03:16 < adrian> lrx33: somehow run_tx_param() is called with ibp_rate0 = 0, and things take a shit
03:16 < adrian> lrx33: so I fixed that, and now I'm debugging why it ain't getting a dhcp lease and stuff
03:16 < adrian> lrx33: likely I need to be closer to my upstairs ap when in 5g mode, heh
03:17 < adrian> lrx33: but hey, lsat now I have it!
16:41 < adrian> lrx33: ok, I just enabled 5G too
16:41 < adrian> lrx33: I'm using 5g HT/20 right now on my USB-N66
16:41 < adrian> lrx33: and we already have some code to extract the antenna config from the eeprom; it's how it prints the MIMO 
                config
16:41 < adrian> run0: MAC/BBP RT3593 (rev 0x0402), RF RT3053 (MIMO 3T3R)
16:42 < adrian> lrx33: but I don't know yet if this matches linux and its assumptions for the number of 11n streams. Antennas != streams. :-)
17:30 < adrian> cool, upstairs I get MCS7 quite stable
17:30 < adrian> gues it's time to go add 2 and 3 stream rates
17:30 < adrian> lrx33: wanna update to get the 5g changes, and then look at the 2/3 stream antenna config and see if we already 
                read the ROM correct? to print out that MIMO data at attach?
17:30 < adrian> lrx33: that would be super nice
18:54 < adrian> lrx33: so far it SEEMS to work, I'm doing 5g 3-stream rates right now (and AMRR is still sucking, but)
18:54 < adrian> lrx33: but if you could go compare our driver to linux for antenna/eeprom config that would be super helpful
19:03 < waddlespl> is AMRR a driver problem or net80211 problem?
19:12 < lrx33> adrian: got your 5g changes. MIMO streams dont have to be equal to number of antennae...but must be strictly less 
               than the num antennae though, right?
19:18 < lrx33> adrian: Also, dmesg reports for the usb n66, run0: MAC/BBP RT3593 (rev 0x0402), RF RT3053 (MIMO 3T3R), address 
               30:85:a9:37:1a:05
19:18 < lrx33> Usually, does hardware have different behavior based on the RF or the MAC? Seems like a lot of switch casing around 
               RF numbers but not a lot around MAC?
19:31 < idwer> yeah, iwx should be backportable to stable/12.. with i386 too? well, there is a remark in phabricator
20:07 < adrian> waddlespl: it's amrr in net80211
20:07 < adrian> lrx33: equal or less
20:07 < adrian> lrx33: older nics used more antennas than streams to get more receive SNR
20:08 < adrian> lrx33: so I have to be careful with ath NICs as they can have 2 or 3 antennas but be 1x1, 1x2, 2x1, 2x2 devices
20:08 < adrian> lrx33: (I've even seen a 2T3R setup to save on power)
20:08 < adrian> lrx33: so yeah, normally there's more variation on the RF side
20:08 < adrian> heh, it's pretty nice to watch rate control work right when I drop the tx power down and up again
20:09 < adrian> lrx33: and yeah, I'm running the n66 right now on 5ghz 3x3
20:09 < adrian> lrx33: AMRR is getting to around mcs17/18 and staying there; i'm up in the same room as the AP
20:23 < lrx33> adrian: that's pretty cool :)
20:23 < lrx33> adrian: I wonder how we could get MCS23... or is that just a unicorn :[
20:32 < adrian> i bet i could with a bit of poking, but right now we need to triple check the rf code, ths treams code
20:32 < adrian> making sure we're calibrated right, the power setup is right, etc
20:32 < adrian> all that fun RF code
20:33 < adrian> AMRR isn't exactly making the smartest decisions. :-P
20:35 < lrx33> :D I'm looking at the RF code, linux seems to be reading in the number of rx/txchains (is chain really an antenna 
               element? what is a chain?) from a completely different place compared to our driver
20:42 < lrx33> adrian: nvm, there's another level of indirection, we read from the correct location
21:08 < lrx33> I think we are in the clear regarding streams, we read from the same location as rt2x00, and we set the ampdu stuff 
               based on them the same way
21:08 < lrx33> https://github.com/torvalds/linux/blob/master/drivers/net/wireless/ralink/rt2x00/rt2800lib.c#L9637 has a list of 
               channels that our RF supports in the linux driver, maybe we should do something with this and adding 5ghz channels 
21:23 < lrx33> Seems like we're doing LNA, and hw radio switch detection the same way as linux. We DONT do any Bluetooth 
               coexistence logic, DONT do EIRP tx power limit checking.
21:23 < lrx33> This concludes the tour of rt2800_init_eeprom from linux ; )
21:35 < lrx33> I made the streams change, please have a look at https://reviews.freebsd.org/D25108
21:35 < lrx33> adrian: ^
21:37 < idwer> the variable name fixup is unrelated to *xstream
21:38 < lrx33> idwer: yeah, that's true, its a fragment from the past 802.11n review
21:38 < lrx33> same goes for module dependencies
21:47 < lrx33> adrian: About getting the power setup right, is this only relevant for setting the right power when tuning to a 
               channel?
22:29 < adrian> oh interesting
22:29 < adrian> btcoex would be nice
22:30 < adrian> lrx33: cool
22:30 < adrian> lrx33: i'll commit it after this meeting
22:36 < adrian> oops shit committed without the review reference, brb
22:37 < adrian> (will commit something else and link it ok)
Day changed to 03 Jun 2020
00:09 < lrx33> adrian: I'm not sure about what btcoex support we already have, and how important it is to have? (btcoex vs ht40 
               for example)
00:09 < lrx33> adrian: thx for merging in those bits
00:10 < lrx33> adrian: about the module dependencies in run, should the run module not depend on wlan_xxx modules?
00:10 < lrx33> adrian: is next ht40? what can I look at next? 
00:10 < lrx33> s/can/should/

